package unionFind;

import java.util.Arrays;

/**
 * In a network of nodes, each node i is directly connected to another node j if
 * and only if graph[i][j] = 1.
 * 
 * Some nodes initial are initially infected by malware. Whenever two nodes are
 * directly connected and at least one of those two nodes is infected by
 * malware, both nodes will be infected by malware. This spread of malware will
 * continue until no more nodes can be infected in this manner.
 * 
 * Suppose M(initial) is the final number of nodes infected with malware in the
 * entire network, after the spread of malware stops.
 * 
 * We will remove one node from the initial list. Return the node that if
 * removed, would minimize M(initial). If multiple nodes could be removed to
 * minimize M(initial), return such a node with the smallest index.
 * 
 * Note that if a node was removed from the initial list of infected nodes, it
 * may still be infected later as a result of the malware spread.
 * 
 * 
 * 
 * Example 1:
 * 
 * Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0
 * 
 * Example 2:
 * 
 * Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] Output: 0
 * 
 * Example 3:
 * 
 * Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] Output: 1
 * 
 * 
 * Note:
 * 
 * 1 < graph.length = graph[0].length <= 300
 * 
 * 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1
 * 
 * 1 <= initial.length < graph.length
 * 
 * 0 <= initial[i] < graph.length
 * 
 * Solution: Union found all nodes.
 * 
 * Count the union size of each union set.
 * 
 * Count the malware number of each union set.
 * 
 * Return the biggest union's malware if there is one and only one malware.
 * 
 * If no such union that has and has only one malware, return the malware with
 * minimum index.
 * 
 */
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Arrays.sort(initial);
        int len = graph.length;
        int maxGroup = 0;
        int target = initial[0];
        int[] parent = new int[len];
        Arrays.fill(parent, -1);
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len; j++) {
                if (graph[i][j] == 1) {
                    union(parent, i, j);
                }
            }
        }
        int[] size = new int[len];
        // count the size of each union set
        for (int i = 0; i < len; i++) {
            size[find(parent, i)]++;
        }
        // count the malware number of each union set
        int[] malware = new int[len];
        for (int i = 0; i < initial.length; i++) {
            malware[find(parent, initial[i])]++;
        }
        // find the largest number of union set if there is one and only one malware in the union set
        for (int i = 0; i < initial.length; i++) {
            if (malware[find(parent, initial[i])] == 1 && maxGroup < size[find(parent, initial[i])]) {
                maxGroup = size[find(parent, initial[i])];
                target = initial[i];
            }
        }
        if (maxGroup != 0) {
            return target;
        }
        return initial[0];
    }

    private int find(int[] parent, int i) {
        if (parent[i] == -1) {
            return i;
        }
        parent[i] = find(parent, parent[i]);
        return parent[i];
    }

    private void union(int[] parent, int i, int j) {
        int parentI = find(parent, i);
        int parentJ = find(parent, j);
        if (parentI != parentJ) {
            parent[parentI] = parentJ;
        }
    }
}